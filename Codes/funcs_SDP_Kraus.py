import numpy as np
from numpy import linalg as la
import picos as pic
import cvxpy as cp
from scipy.spatial import ConvexHull
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib import pyplot as plt
import SM as sm
import Measurements as me

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------CONSTRUCING POLYHEDRON AND FACETS EQUATIONS-----------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

def poly(vertices):
    hull = ConvexHull(vertices)
    faces = hull.equations
    A = faces[:, :-1]
    b = faces[:, -1]
    m = np.size(A,0)
    xint, yint, zint = np.sum(vertices,0)[0]/m, np.sum(vertices,0)[1]/m, np.sum(vertices,0)[2]/m
    for i in range(m):
        if A[i,:]@np.array([[xint], [yint], [zint]]) - b[i] > 0:
            A[i,:] = -A[i,:]
            b[i] = -b[i]
    
    # Delete identical facets possibly generated by the algorithm
    indices = []
    for i in range(A.shape[0]):
        for j in range(i+1,A.shape[0]):
            if all(A[i,:] == A[j,:]) == True and b[i] == b[j]:
                indices.append(i)

    A_new = np.delete(A, indices, 0)
    b_new = np.delete(b, indices)

    return A_new, b_new

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------OPTIMIZING LINEAR TRANSFORMATION FROM BLOCH SPHERE TO MAXIMUM VOLUME INSCRIBED ELLIPSOID--------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

def ellipsoid(vertices):
    A, b = poly(vertices)[0], poly(vertices)[1]

    B = cp.Variable((3,3)) #Contains rotations and shrinking factors
    d = cp.Variable((3,1)) #Translation vector

    constraint_list = [cp.norm(B@A[i,:].T) + A[i,:]@d <= b[i] for i in range(np.size(A,0))]

    E = cp.Problem(cp.Maximize(cp.log_det(B)), constraint_list)

    E.solve()

    Be = np.round(B.value, decimals = 5)
    de = np.round(d.value, decimals = 5)

    O1, ETA, O2 = la.svd(Be) #Separate rotations and shrinking factors
    ETA = np.diag(ETA)
    O1, ETA, O2 = np.round(O1, decimals = 5), np.round(ETA, decimals = 5), np.round(O2, decimals = 5)

    return Be, ETA, O1, O2, de

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------PLOTTING POLYHEDRON AND OPTIMAL INSCRIBED ELLIPSOID---------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

def plot_all(vertices):

    hull = ConvexHull(vertices)
    Be, de = ellipsoid(vertices)[0], ellipsoid(vertices)[4]

    theta, phi = np.linspace(0.0, np.pi, 100), np.linspace(0.0, 2*np.pi, 100)
    THETA, PHI = np.meshgrid(theta, phi) #malha de variação angular
    m, n = np.size(THETA,0), np.size(THETA,1)
    X, Y, Z = np.sin(THETA)*np.cos(PHI), np.sin(THETA)*np.sin(PHI), np.cos(THETA)
    m, n = np.shape(X)
    X = X.reshape(1,m*n)
    Y = Y.reshape(1,m*n)
    Z = Z.reshape(1,m*n)

    XEP, YEP, ZEP = np.empty(m*n), np.empty(m*n), np.empty(m*n)
    for i in range(m*n):
        x, y, z = X[0,i], Y[0,i], Z[0,i]
        cir = np.array([[x], [y], [z]])
        ep = Be@cir + de
        XEP[i] = ep[0]
        YEP[i] = ep[1]
        ZEP[i] = ep[2]

    XEP = XEP.reshape(m,n)
    YEP = YEP.reshape(m,n)
    ZEP = ZEP.reshape(m,n)

    fig = plt.figure()
    ax = plt.axes(projection = '3d')

    polys = Poly3DCollection([hull.points[simplex] for simplex in hull.simplices])

    polys.set_edgecolor('deeppink')
    polys.set_linewidth(.8)
    polys.set_facecolor('hotpink')
    polys.set_alpha(.25)

    ax.add_collection3d(polys)
    ax.plot_surface(XEP, YEP, ZEP, alpha = 0.9)

    plt.show()

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------CALCULATING KRAUS OPERATORS---------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

def ellipsoid__map(vertices, i, vx, vy, vz): #Map represented by the ellipsoid on a general element i*I + vx*sigmax + vy*sigmay + vz*sigmaz

    Be = ellipsoid(vertices)[0]
    V = np.array([[vx],[vy],[vz]])
    M_V = (sm.I + vx*sm.sigmax + vy*sm.sigmay + vz*sm.sigmaz)/2
    V_prime = Be@V
    eta_v = la.norm(V_prime)
    vx_p, vy_p, vz_p = V_prime[0,0], V_prime[1,0], V_prime[2,0]
    M = 1/2*np.array([[i*(eta_v + 2*(1-eta_v)*(np.trace(sm.ketbra_00@M_V))) + vz_p, vx_p - vy_p*1j], [vx_p + vy_p*1j, i*(eta_v + 2*(1-eta_v)*(np.trace(sm.ketbra_00@M_V))) - vz_p]])

    return M

def Choi(vertices): #Choi matrix associated with the ellipsoid map
    
    LAMB_00 = np.kron(sm.ketbra_00, ellipsoid__map(vertices, 1, 0, 0, 1))
    LAMB_01 = np.kron(sm.ketbra_01, ellipsoid__map(vertices, 0, 1, 1j, 0))
    LAMB_10 = np.kron(sm.ketbra_10, ellipsoid__map(vertices, 0, 1, -1j, 0))
    LAMB_11 = np.kron(sm.ketbra_11, ellipsoid__map(vertices, 1, 0, 0, -1))

    LAMB = LAMB_00 + LAMB_01 + LAMB_10 + LAMB_11

    return LAMB

def func_Kraus(vertices): #Kraus operators of the map, calculated from the Choi matrix

    lamb, ket_lamb = la.eigh(Choi(vertices))

    ket_m = np.empty(ket_lamb.shape, dtype=complex)
    for j in range(ket_lamb.shape[1]):
        m = np.emath.sqrt(lamb[j])*ket_lamb[0:,j]
        ket_m[:,j] = m

    Kraus = np.empty((ket_m.shape[1], int(ket_m.shape[0]/2), int(ket_m.shape[0]/2)), dtype=complex)
    for k in range(ket_m.shape[1]):
        m = ket_m[:,k]
        dim = int(len(m)/2)
        Kraus[k] = (np.reshape(m, (dim,dim))).T

    return Kraus

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------GENERATING STRATEGIES---------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Creating the strategies_LHS(m,k) function
def strategies_LHS(m,k):
    #INPUT: m = number of measurements; k = number of results
    #k**m = number of strategies = n_lambdas

    n_lambdas = k**m
    
    #Creating the strategies
    all_est = [np.base_repr(el+n_lambdas,base=k)[-m:] for el in range(n_lambdas)]
    
    all_est = np.array([[int(digit) for digit in el] for el in all_est])

    detp = np.zeros((n_lambdas,k*m))

    for i in range(n_lambdas):
        for j in range(m):
            aux = np.zeros(k)
            aux[all_est[i][j]] = 1
            detp[i][j*k:j*k+k] = np.array(aux)    
            
    #Return the deterministic strategies
    return detp

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------SDP---------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Creating the SDP_LHS(m,k,rho,rho_sep,eta,detp,medicoes) function
def SDP_LHS(rho,rho_sep,vertices, plot = False):

    if plot == True:
        plot_all(vertices)

    medicoes = me.measurements(vertices)
    m_k = medicoes.shape
    k = 2
    m = int(m_k[0]/k)
    detp = strategies_LHS(m,k)

    #Creating the problem
    P = pic.Problem()

    #Creating the optimization variables
    q = pic.RealVariable('q')

    chi = pic.HermitianVariable('chi',(4,4))

    sigma = [pic.HermitianVariable('Sigma_lambda[{}]'.format(i),(2,2)) for i in range(k**m)]

    rho_q = rho*q+(1-q)*rho_sep

    Kraus = func_Kraus(vertices)
    
    rho_eta = pic.sum([np.kron(np.conj(Kraus[i]).T,sm.I)*chi*np.kron(Kraus[i],sm.I) for i in range(4)])

    est_det = [pic.sum([sigma[j]*detp[j,i] for j in range(k**m)]) for i in range(k*m)]

    est = [(np.kron(medicoes[i],np.eye(2)))*chi for i in range(k*m)]

    #Creating the constraints
    P.add_constraint(q<=1)

    P.add_constraint(q>=0)

    P.add_list_of_constraints([sigma[i]>>0 for i in range(k**m)]) 

    P.add_constraint(rho_q == rho_eta)

    P.add_list_of_constraints([pic.partial_trace(est[i],subsystems=0,dimensions=(2,2))==est_det[i] for i in range(k*m)])

    #Setting the objective
    P.set_objective('max',q)

    #Finding the solution
    solution = P.solve(solver='mosek', primals=None)

    #Return the problem created, the solution found, the value of q
    return P, solution, q, solution.value